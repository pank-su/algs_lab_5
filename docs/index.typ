#import "lib/gost.typ": init

#show: init

= Цель работы

Изучение алгоритмов внутренней сортировки
и получение практических навыков их использования, и анализа их
сложности.

= Вариант задания

Использовать неупорядоченный массив A, содержащий n
целочисленных элементов. Величина n определяется по согласованию с
преподавателем. Дополнительно в программе должны быть реализованы
следующие функции:
+ Поиск элемента либо по его порядковой позиции, либо по его
  содержимому;
+ Добавление/удаление элемента с последующей пересортировкой
  последовательности;
+ В программе должен быть реализован подсчет количества
  сравнений и перестановок, при осуществлении сортировки.

Вариант 25

Найти $k$-ое по порядку число среди элементов массива. Использовать алгоритм сортировки: Шейкерная

= Листинг программы

#raw(read("../src/main.kt"), lang: "kt", block: true)

= Контрольный пример

В контрольном примере неотсортированный массив будет состоять из следующих элементов и в следующем порядке: 5, 10, 10, 8, 1, 7

Ожидаемый выходной отсортированный массив: 1, 5, 7, 8, 10, 10.
Ожидаемое количество сравнений: 14
Ожидаемое количество перестановок: 9

Вывод программы:

```text
Количество сравнений: 14
Количество перестановок: 9
```

= Временная и пространственная сложность алгоритма

Разработанный алгоритм использует следующие данные:

- 2 массива размерностью $n$, заполненные целыми числами
- логическую переменную
- 5 целочисленных переменных

Пространственная сложность алгоритма:

$
   v = 2n dot C_"int" + 2 dot C_"bool" + 6 dot C_"int"
$

где:

- $C_"int"$  -- константа объема памяти для хранения целочисленного значения
- $C_"bool"$ -- константа объема памяти для хранения логического значения


Теоретическая пространственная сложность алгоритма составляет:

$
    V(n) = O(v) = O(max(2n dot C_"int" + 2 dot C_"bool" + 6 dot C_"int")) = O(2n + 1 + 5) = O(n)
$


Рассчитаем теоретическую временную сложность алгоритма. Для операций присвоения, сравненения примем временную сложность "1". Для упрощения вычислений рассчитаем только цикличные операции.

Циклы `for` в строке 124  и 140 в худшем случае будет выполняться за $n-1, n-2, ... 1$

Тогда общая временная сложность цикла `do while` в строке 119 в худшем случае будет равна сумме всех возможных временных сложностей внутренних циклов `for`:  $n-1 + n-2, +  ... + 1 = sum^(n-1)_1 n - i = 1/2(n-1)n$

Найдём теоретическую временную сложность алгоритма сортировка:

$
    T = O(max(1/2 (n-1) n)) = O(n^2)
$

== Вывод

Рассчитанная временная сложность совпадает с временной сложностью представленная в методических указаний, что подтверждает корректность реализации.


= Скриншоты работы программы

= Выводы

Изучил алгоритмы внутренней сортировки
и получил практические навыки их использования, и анализа их
сложности.

